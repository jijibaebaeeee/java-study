day02
java란 -> 개발환경, 설치 -> 자료형과 변수 -> 이스케이프 문자, 출력메소드
day03
자료형과 변수 -> 제어문자, 출력메소드, 서식문자 -> 형변환 -> 입력메소드 -> 연산자
유니코드와 정수와의 관계 정도?★★★★★★
day04
복습 -> 입력메소드 -> 연산자 -> 제어문(조건문)

day05
복습 -> 연산자2 -> 제어문(조건문, 반복문)

day06
복습 -> 반복문(do~while문) -> 이중 for문 -> 배열
※별찍기 강수!★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

day07
교재복습 -> 배열(Array)

----------------------------------------------------------------------
day08
복습(과제) -> 2차원 배열 -> 메소드
(얕은 복사 + 깊은 복사)?
day09
복습 -> 메소드2 -> 클래스1
day10
없음
day11
클래스 -> 객체 -> 생성자 -> 오버로딩 -> this, this()
day12
복습 -> static -> 변수의 종류 -> enum 열거형 -> 상속 -> 접근제한자
day13
시험2문제 + 과제 3문제 -> 복습 -> Casting -> 추상클래스 -> 인터페이스 -> 어댑터클래스
day14
복습 -> 추상클래스 -> 인터페이스 -> 어댑터클래스 -> 내부클래스 -> 익명클래스 -> 람다식


day07
교재복습 -> 배열(Array)
설마 버블정렬......................................................................................?

day08
메소드
-> 메인에서 Scanner sc = new Scanner(System.in); 을 했고 ★★★★★★
   메소드에서 사용자의 입력을 받아 배열을 채우고 싶다면
   insertValue(arr, Scanner sc){
	num = sc.nextInt(); 
   }    				가 가능하다.

2차원의 깊은 복사를 하려면 그냥 for문 2번을 돌리는 것이 안 헷갈리고 좋다.
Arrays.deepToString
Arrays.toString
Arrays.copyOf(배열, 배열.length)

day09
메소드 + 팀 문제

day10
클래스 + 메소드 + 생성자
TvController 만들기 -> 생성자를 이용해서 객체 초기화하고, 메서드 호출하기
switch문 + while문. 조건 잘 생각할 것★★★★★★★★★★★★★★★★★★

day11
없음.

day12
기초 상속
static 메소드와 vs 인스턴스 메소드

static 키워드가 붙었을 때 객체를 만드는 것이 오히려 권장이 아니다.
static -> 클래스명.메소드명() 으로 접근할 것  ★★★★★★
 
인스턴스 메소드의 경우는 무조건 객체를 만들어야함. ★★★★★★

※1206 테스트
클래스 필드 + 메서드를 이용하고 + 객체를 생성해서 접근하기.
1차원 배열에 값을 넣고 크기를 서로 비교해서 큰값 작은값 모두 출력하기 + 인덱스

day13
캐스팅 + private
private + getter + setter 로 음수 제어하기 ★★★★★★★★★★
But, private String name인데 생성자에 this.name = name 있을 시 접근 가능해!
출력은 getter로 하기 신기하다.
상속관계라면 부모의 참조변수로 자식의 참조값을 받을 수 있음. 캥거루를 생각하면 쉬움
배열까지 만들 수 있어서 인수로 넘기기도 좋고. 부모의 타입으로 선언되면 자신의 것은 잠시 못쓴다.
upcasting이라고 하고 오버라이딩된 함수가 호출된다! 없으면 부모의 것으로 호출되것지!


day14
추상클래스 + 인터페이스 + 어뎁터까지 이해를 해야함 완 벼 억 하 게 에

추상클래스 : 필드 + 메소드 + 생성자 + 추상메소드 있는 것.
	추상메소드가 하나라도 있으면 abstract 키워드가 붙어야함.
	절대 객체를 바로 만들 수 없고, 상속받은 자식에서 오버라이딩되어야 객체화 가능.
	이때 자식에서 부모클래스로 업캐스팅은 허용한다.
	오버라이딩을 해도 추상클래스가 객체를 스스로 만드는 것은 허용되지 않는다.
	사실상 다운캐스팅을 해서 출력을해도 같은 결과가 나온다.

인터페이스 : 상수 + 추상메소드가 있는 것. but, 추상메소드가 있어도 abstract 안 붙음(그게 아니라. public abstract이 숨어있는거야.)
	   구현한다는 뜻으로 implements 키워드 필수.
	   다중상속을 지원한다. (Inter0 extends Inter1, Inter2) 오버라이딩 필요 X
	  클래스에 할당되기 전까지는 오버라이딩 안해두 된다.
	  인터페이스는 구현이되어도 자신이 직접 객체를 만들수는 없다.
	  다만 업캐스팅을 위해 Inter inter1 = new Person(); 은 가능하다. Person은 업캐스팅된다.
	  인터페이스에 default 키워드가 붙으면






