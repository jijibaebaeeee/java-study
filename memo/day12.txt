day12
복습 -> static -> 변수의 종류 -> enum 열거형 -> 상속 -> 접근제한자

0. 복습
  1) 클래스
	class  클래스명{
		//멤버
		//필드
		//메소드
		//생성자
	}
  2) 객체화(인스턴스화)
	클래스명 객체명 = new 생성자();

  3) 생성자(Constructor)
	new 키워드로 객체를 생성할 때 객체의 필드를 초기화 역할
	
	생성자의 오버로딩	: 매개변수 순서, 타입, 개수가 다르면 같은 이름으로 선언할 수 있다.
	컴파일러 기본생성자 
		public 생성자(){
		
		}
	
  4) this, this()
	this : 객체 자기자신(참조값)
	this() : 자기자신의 생성자

  5) 가변길이 메소드
	인수가 몇 개 올지 모를 때 사용
	여러 개의 가변 길이 매개변수를 동시에 선언할 수 없다. -> java에서 가변길이 매개변수가
	마지막 매개변수 처리되기 때문에 충돌을 방지하려는 제약때문이다.

--------------------------------------------------------------------------------

1. static 
	프로그램이 실행되는 동안 계속해서 유지되는 저장공간
	프로그램이 시작하면 생성되고 프로그램이 종료될 때까지 유지되는 것
	JVM의 클래스로더가 프로그램 시작시 읽음	
	heap stack method 메모리 중 method 메모리에 생성
	
  1) 정적 멤버(Static Members)
	정적 멤버는 클래스 자체에 속하는 멤버로, 클래스를 통해 접근
	객체를 생성하지 않아도 사용할 수 있다
	정적변수와 정적 메소드가 포함된다.

    - 정적 변수 : 클래스의 모든 인스턴스(객체)에서 동일한 값을 공유, 객체간의 정보공유에 사용된다.
    - 정적 메소드 : 객체를 생성하지 않아도 호출 가능, 주로 유틸리티 메소드(정적메소드)나 공통 동작을 구현하는데 사용된다.

  2) 멤버 변수, 멤버 메소드의 종류
	static이 붙은 변수 : static 변수, 클래스 변수, 정적변수
	static이 안 붙은 변수 : 인스턴스 변수

	static이 붙은 메소드 : static 메소드, 클래스 메소드, 정적 메소드
	static이 안 붙은 메소드 : 인스턴스 메소드

  3) static 변수와 static 메소드
	static 변수, static 메소드는 객체를 생성하지 않아도 클래스 이름을 통해 직접 사용할 수 있다
	객체의 생성과는 무관하게 클래스 로딩 시에 메모리에 올라가며 프로그램이 실행되는 동안 유지된다.

	static 변수는 객체와 상관없이 하나의 저장공간이므로 모든 객체가 공유해서 사용한다
	즉, 모든 객체에 공통으로 사용되는 변수에 static을 붙이는 것을 고려한다.

	static 메소드는 인스턴스 멤버를 직접 사용할 수 없다
	static 메소드가 메모리에서 사용 준비가 끝나고 인스턴스 멤버는 new를 사용하여 객체를 생성하기 전까지
	사용할 수 없기 때문이다.

	static은 프로그램이 시작되자마자 생성되므로, 나중에 생기는 객체에 대한 정보를 모른다
        -> 이러한 이유로 static에서는 (인스턴스변수, 인스턴스메소드) 를 호출할 수 없다.

  +) 정적변수는 클래스 수준에서 선언되며 클래스의 모든 객체간에 공유되는 변수이다.
     한번 메모리에 할당되면 프로그램이 실행중일 때 항상 존재하며 수정될 수 있다.
     클래스가 처음 사용되거나 정적멤버에 접근되면 해당 클래스가 메모리에 로드되고, 클래스의 정적변수 및 정적 메소드가 method 영역에 할당되는데 이 과정을 클래스 로딩이라고 한다.
     정적 변수의 변경은 해당 클래스의 모든 객체에 영향을 끼친다.
     method 영역은 가비지컬렉션의 영향을 받지 않는다(자동으로 메모리를 해제를 해주는 -> 가비지컬렉션) 
     객체가 해제되더라도 method 영역에 할당된 데이터는 프로그램의 종료까지 유지된다.

  +) 메모리 구조
	Method 영역(JVM 관리하는 공유 메모리~)
	- 모든 클래스와 static 멤버가 저장되는 영역
	- 클래스 로더가 클래스를 로드할 때 해당 클래스의 메타데이터와 함께 static 변수와 static 메소드가 여기에 저장된다.
	- 프로그램 실행동안 유지되며 모든 객체가 공유한다.

	Heap 영역
	- new 키워드로 생성된 객체와 그 객체의 인스턴스 변수가 저장된다.
	- 객체마다 별도의 공간을 가짐
	- Garbage Collector가 관리

	Stack 영역(메소드 내부에서 선언된 변수 main에서 사용 x)
	- 메소드의 지역변수와 메소드 실행 정보가 저장되는 영역
	- 메소드가 호출될 때 스택 프레임이 생성되고, 종료되면 프레임이 제거된다.

	PC Register(프로그램 카운터 레지스터)
	- 각 스레드가 실행중인 명령어의 주소를 저장

	Native Method Stack(네이티브 메소드 스택)
	- Java가 아닌 네이티브 코드(C, C++ 등)로 작성된 메소드를 호출 시 사용



  4) 정적 블록 -> 데이터베이스의 연결을 초기화하는 경우 사용함. (Java - DB 연결시)
	클래스가 로드될 때 실행되는 블록
	주로 정적 멤버를 초기화 하는 데 사용된다
	모든 인스턴스가 생성되기 전에 실행되므로 초기화 작업에 유용하다
	로드시점 : 클래스가 처음 로드될 때 실행된다.
		 - 클래스의 객체가 생성될 때(클래스 인스턴스화)
		 - 클래스의 정적멤버(스태틱변수나 스태틱메소드)에 접근할 때
		 - 클래스를 사용하는 다른 클래스가 로드될 때(참조하려는 클래스에 의존성이 있는 경우)
	
	static{	  <- 정적블록

	}



 ※ 프로그램이 실행되자마자 static이 실행되므로 처음부터 시작되는 것이 필요할 때도 사용 가능
	DB연동시 사용
   

2. 변수의 종류
	지역변수		클래스 중괄호 영역은 포함되지 않으며/// 메소드나 생성자 등 그 안의 중괄호 영역에서 선언된 변수
			해당 메소드가 실행되는 동안에만 유지, Stack 영역에 저장, 초기화를 반드시 해야 사용가능
	
	매개변수		메소드의 소괄호 안에서 선언된 변수
			Stack 영역에 저장, 메소드 실행 중에만 유효, call by value 기본으로 사용
	
	인스턴스변수	클래스 중괄호 영역에서 선언된 변수(클래스 내부, 메소드 밖에 위치)
			heap 영역에 저장, 객체마다 별도로 생성되므로 독립적인 값을 가짐
			초기화를 하지 않으면 JVM이 기본값으로 초기화
	
	정적변수		static이 붙은 모든 변수, 객체간 공유, 편의성
			method 영역에 저장, 객체 없이 사용 가능

3. final
	final	변수 	상수
	final	메소드	오버라이딩 불가
	final	클래스	상속 불가

4. enum 열거형
	일련의 고정된 값(상수)들을 나타내기 위한 특별한 데이터 유형
	클래스 타입(reference type)으로 취급된다.

  1) enum을 사용하는 이유
	코드의 가독성과 안정성
	컴파일 타임 오류 방지
	관련 데이터와 동작을 묶을 수 있음

  2) 문법
	enum Day{
		MONDAY, TUESDAY, WENDESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;
	}

  3) 특징
	enum에 선언된 값은 상수 객체로, 각 값은 컴파일 시점에 고유한 인스턴스로 생성된다.
		값의 순서는 0부터 시작하며 순서를 정수로 얻으려면 ordinal() 메소드를 사용한다
	열거형 배열
		values() 모든 열거형 값을 배열로 얻을 수 있다
	name(), valueof()
		name() : 열거형 이름(문자열)을 반환
		valueOf(문자열) : 문자열을 열거형 값으로 반환
	
5. 상속(Inheritance)
	기존에 선언된 클래스의 멤버(생성자는 제외)를 새롭게 만들 클래스에서 사용하고 싶을 때
	상속을 받고 새로운 기능만 추가한다.
	여러 클래스 선언시 멤버가 겹치는 경우, 부모 클래스에서 먼저 선언하고 공통멤버를 자식 클래스들에게 상속해준다.

  1) 상속 문법
	class Parents{
		//Parents 클래스의 멤버
	}
	
	class Child extends Parents{
		//Child 클래스의 멤버 

	}

	//Parents : 부모클래스, 슈퍼클래스, 기반클래스, 상위 클래스
	//Child   : 자식클래스, 서브클래스, 파생클래스, 하위 클래스

	※자바는 단일 상속만 지원한다!!!!

  2) super, super()
	super : 부모의 참조값
		부모의 멤버에 접근할 때 사용한다
	super() : 부모의 생성자
		  자식 클래스 타입의 객체로 부모 필드에 접근할 수 있다
		  객체를 만들 때 자식 생성자만 호출하기 때문에 자식 필드만 메모리에 할당된다고 생각할 수 있다.
		  ex) Child child = new Child();
		  자식 생성자는 항상 부모 생성자를 호출한다.
		  이는 자식의 필드를 초기화할 때 부모 필드도 초기화하는 것을 의미한다
		  즉, 자식 객체를 생성하게 되면 부모 객체도 생성하게 된다(부모객체가 먼저 생성됨)
		  부모 생성자를 호출하는 방법은 super()를 사용하면 된다
		  만약 super()를 작성하지 않더라도 컴파일러가 자동으로 작성해준다.


	※부모의 생성자가 매개변수를 받는다면
	  자식의 생성자에서도 매개변수를 받아야한다.

	 자식클래스(매개변수1, 매개변수2, 매개변수3, 매개변수4, ...){ 
	   super(매개변수1, 매개변수2, 매개변수3)  // 부모의 생성자를 호출하게 그에 맞게 인수를 꽊꼬가 채워 드려야한다.
	   this.매개변수4 = 매개변수4;
	   }

  +) this(), super()
	super() : 부모 클래스의 생성자를 호출
		  부모 클래스 초기화를 위해 사용한다
		  만약 부모 클래스에서 매개변수가 있는 생성자만 존재한다면 자식클래스에서 반드시 명시적으로 작성해야한다.
	
	this() : 같은 클래스의 다른 자기자신의 생성자를 호출
		 오버로딩된 생성자에서 중복된 코드를 줄이기 위해서 사용한다.

  3) 다형성 : 하나의 것으로 여러 형태를 가지는 것을 의미
	- 오버로딩 : 같은 클래스 내에서 생성자나 메소드를 같은 이름으로 매개변수의 타입, 순서, 개수만 다르게 만드는 것
		   반환타입은 오버로딩에 영향을 주지 않는다
	
	- 오버라이딩(재정의) : 부모클래스에 정의한 메소드를 자식 클래스에서 수정해서 사용하고 싶을 때 사용한다
			   상속관계일 때 가능
			   이 때 메소드명, 매개변수, 반환타입은 부모클래스의 메소드와 동일해야한다(구현부{}만 변경한다)

  +) 오버로딩과 오버라이딩의 차이

	특징		오버로딩					오버라이딩
	정의위치		같은 클래스 내에서 동일한 이름의 메소드		부모클래스에 정의된 메소드를 재정의
	메소드 문법	이름만 같고 매개변수 타입,개수,순서가 다름	부모클래스와 완전히 일치해야함
	관계		상속관계 필요없음				상속단계가 필수 
	사용목적		메소드의 다중 정의				동작 변경(구현부 재정의)

  4) 오버라이딩을 사용하는 목적
	- 다형성 구현 : 부모클래스의 참조변수로 자식클래스의 객체를 다룰 수 있게 하기 위함(다음주 월요일에 배움)
	- 동작 변경 : 부모클래스의 기본 동작을 자식클래스의 요구사항에 맞게 변경
	- 유지보수성 향상 : 공통기능을 부모 클래스에 정의하고 필요한 부분만 자식클래스에서 변경



6. 접근 권한 제어자(Access Modifiers)
제어자		같은 클래스	같은 패키지	다른 패키지(상속관계 없을때)		다른 패키지(상속관계 있을때)
public		O		O		O				O
protected	O		O		X				O
(default)	O		O		X				X
private		O		X		X				X

  1) public
	클래스, 필드, 메소드, 생성자 사용 가능
	모든 곳에서 접근이 가능하다
	ex) 공용 API 메소드, 유틸리티 클래스, 대표 클래스

  2) protected
	필드, 메소드, 생성자에 사용가능
	클래스 자체의 접근 제어자는 public과 default만 사용 가능하고 protected는 상속관계에서 접근을 제어하는 기능을
	제공하고 있으므로 클래스 자체에는 의미가 없다

  3) (default)
	패키지 내부에서만 사용할 클래스, 메소드에 사용
	같은 패키지에서만 접근 가능
	다른 패키지에서는 상속관계와 상관없이 접근 불가

  4) private
	같은 클래스 내부에서만 접근 가능
	외부 클래스는 접근할 수 없고 getter/setter 메소드를 통해 간접적으로 접근 허용
	캡슐화를 위해 주로 사용
	





 ※ protected 는 이미 상속관계가 만들어져 있을 때 아래에서 사용 가능하다는 뜻이다
    클래스의 접근 제한자는 public 이거나 default 만 가능하다.


























