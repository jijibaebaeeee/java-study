day09.

1. 메소드
  1) 메소드와 메모리
	메소드는 실행되면 메모리의 Stack영역에 메소드 실행에 필요한 저장공간이 생성된다.
	그 곳에 메소드 내부에서 선언한 변수(지역변수, 매개변수)들의 저장공간이 생성된다.
	메소드의 코드가 모두 실행되어 종료되면 Stack 영역에서 해당 메소드의 저장공간이 삭제된다(메모리 해제)
	그러면 지역변수의 저장공간이 사라지므로 지역변수느 사용이 불가능하다

  +) 스택 프레임의 장점
	메모리 관리 효율성 : 메소드를 호출 할 때 필요한 메모리를 동적으로 할당하고, 호출이 끝나면 자동으로 해제한다
	재귀적 호출 지원 : 재귀 호출에 각 호출마다 독립적인 스택 프레임이 생성되어, 서로 간섭없이 수행된다
	지역성 : 스택 메모리 접근 속도가 빠르며, 지역변수와 매개변수는 메모리 접근 비용이 적다.

  2) 인수와 매개변수
	인수(Argument) : 메소드를 사용할 때 메소드의 매개변수로 전달될 값
	매개변수(Parameter) : 외부에서 전달받아 값을 저장하고 메소드내에서 사용될 변수

	- 메소드의 인수와 매개변수는 반드시 타입과 일치하거나 자동 형변환이 가능한 타입이어야한다
	- return되는 값은 반드시 return 타입과 일치하거나 자동 형변환이 가능한 타입어어야한다

  3) 메소드의 사용 목적
	- 중복된 코드의 제거
	- 높은 재사용성
	- 유지보수에 유리함

  4) 메소드 오버로딩(Method Overloading) => 다형성 : 같은 코드로 다른 기능을 하는 것 ★★
	Method : 메소드(작업을 수행하는 코드 블록)
	Overloading : 과부하, 너무 많이 실음 이라는 뜻, 프로그래밍에서는 같은 이름을 여러번 사용하는 것을 의미

	같은 이름의 메소드를 여러개 정의하는 것을 의미한다
	매개변수의 개수, 타입, 순서가 다르면 같은 이름의 메소드로 선언할 수 있다
	반환타입은 오버로딩에 영향을 주지 않는다

    - 메소드 오버로딩의 조건
	리턴타입은 같아도 상관없음
	메소드의 이름은 동일해야함
	매개변수의 타입, 개수, 순서중 1개라도 달라야함

    - 메소드 오버로딩의 주의사항
	매개변수의 타입, 개수, 순서가 똑같은 경우 매개변수의 이름이 다르다고 해서 오버로딩이 아니다
	리턴타입만 다르고, 메소드의 이름과 매개변수가 동일한 경우도 오버로딩이 아니다

    - 메소드 오버로딩이 필요한 이유?
	이름의 통일성 : 비슷한 작업을 수행하는 메소드는 같은 이름을 사용하면 직관적이다
	코드 가독성 : 여러 작업을 하나의 이름으로 처리할 수 있기 때문에 코드가 간결해진다(메소드이름을 따로 기억할 필요가 없다)

    - 메소드 오버로딩이 가능한 이유
	컴파일러가 메소드 호출 시 메소드 이름뿐만 아니라 매개변수의 정보를 사용해 정확히 어떤 메소드를 호출할 지 구분하기 때문이다
	컴파일 시 메소드 이름이 다르게 지정됨
	컴파일러는 메소드의 이름과 매개변수의 정보를 합쳐서 고유한 시그니처(Method Signature)를 생성
	시그니처는 메소드이름 + 매개변수의 타입과 개수로 구성

    - 컴파일러가 메소드를 선택하는 과정
	매개변수의 개수 확인 : 메소드 호출시 인수값의 개수와 일치하는 메소드를 먼저 찾는다
	매개변수의 타입 확인 : 메소드 호출시 전달된 인수값의 타입과 일치하는 메소드를 찾는다
	타입 변환 규칙 적용 : 전달된 인수값의 타입과 완전히 일치하는 메소드가 없을 경우, 더 큰 타입으로 변환가능한 메소드를 호출(작은 타입의 값은 큰 타입으로 자동형변환이 가능하기 때문이다)
	int -> long, float, double순으로 자동변환 기능
	큰타입이 호출 우선순위의 뒤에 있다.

-------------------------------------------------------------------------------------------------
* 메소드 호출방법 4가지

	매개변수	리턴값	호출방법
	x	x	객체명.메소드명();
	x	o	syso(객체명.메소드명());  OR 변수 = 객체명.메소드명()
	o	x	객체명.메소드명(인수);
	o	o 	syso(객체명.메소드명(인수));  OR 변수 = 객체명.메소드명(인수)

* 메소드 오버로딩 < - 다형성을 구현하는 한 방법
  각 메소드의 관리 및 유지보수의 효율성을 위해 같은 이름의 메소드명을 여러 개 선언할 수 있게 하는 것
  메소드 오버로딩을 위해서는 매개변수의 타입, 순서, 개수 중에서 1개라도 다름이 있어야한다.
  컴파일러는 메소드명이 같은 각 메소드를 매개변수의 타입, 순서, 개수로 구분하여 시그니처를 만든다.
  유의할 점으로 같은 메소드명 내 return 타입만이 다르다고해서 메소드 오버로딩인 것은 아니다
  또한, 매개변수의 이름은 달라도 메소드 오버로딩이 아니다.
  만약 메소드를 호출했을 때 인수와 매개변수의 타입이 다르면, 형 변환이 가능한 경우에 한해 형 변환을 지원해준다.
  int의 경우 long -> float -> double 순으로 지원한다. 범위가 큰 자료형일 수록 후순위로 간다



* 배열 선언과 생성
 1차원
  (1) 배열의 크기를 아는 경우
	자료형[] 배열명 = new 자료형[크기]

  (2) 배열의 값을 아는 경우
	자료형[] 배열명 = {값1, 값2, 값3, 값4 . . . .}

  (3) 배열의 값을 나중에 입력하는 경우
	자료형[] 배열명;
	배열명 = new 자료형[]{값1, 값2, 값3, 값4,. . .}

  (4) 배열명만 선언하는 경우
	자료형[] 배열명 = null;

 2차원
  (1) 배열의 크기를 아는 경우
	자료형[][] 배열명 = new 자료형[크기][]

  (2) 배열의 값을 아는 경우
	자료형[] 배열명 = {{값1, 값2}, {값3, 값4}, . . . }

  (3) 배열의 값을 나중에 입력하는 경우(?)
	자료형[][] 배열명;
	배열명 = new 자료형[][]{{값1, 값2}, {값3, 값4},. . .}

* 입력 받은 숫자까지 총합을 구하는 메소드(매개변수 o, 리턴타입 o)

 로직구성
  리턴타입 => 정수형
  메소드명 => printSum
  매개변수 => 정수형 1개
  구현부
    총합을 구하는 정수형 변수 1개 선언 -> total
    for문을 사용
	초기 i = 1
	  조건 i <= 입력받은 정수
	     1씩 증가
	total += i;
    return total;

얕은복사 => 참조값이 복사(원본과 복사본이 서로 의존적), 속도 빠름, 메모리 사용량은 적음
깊은복사 => 모든 데이터 복사(원본과 복사본이 서로 독립적), 데이터양에 따라 느려짐, 메모리 사용량은 많음, 데이터독립성이 중요 
	
========================================================================================================

2. call by value 와 call by reference
  1) Call by Value(Pass by Value) : 값에 의한 호출 (Java)
	값을 복사해서 메소드에 전달하는 방식
	메소드를 호출할 때 원본값이 복사되므로, 메소드 내부에서 값이 변경되어도 원본에는 영향을 미치지 않는다.
	메소드에 인수로 전달되는 것은 값 자체 ★
	- 메소드 내부에서 값을 변경해도 

  2) Call by Reference(Pass by Reference) : 참조에 의한 호출
	참조를 전달해서 메소드에 직접 원본 데이터를 조작할 수 있는 방식
	메소드 호출 시 데이터의 주소(참조값)가 전달되므로, 메소드 내부에서 데이터를 변경하면 원본 데이터도 변경됨
	
	- 메소드 내부에서 참조된 객체를 수정하면, 원본 객체도 변경됨
	- c++ 등의 언어에서 지원되며, JAVA는 지원되지 않음

  +) JAVA 동작
	JAVA는 항상 Call by Value로 동작한다
	기본 데이터 타입 : 값 자체가 복사되어 전달
	참조 타입 : 객체의 참조값(주소)이 복사되어 전달되므로 객체 내부의 데이터는 수정할 수 있지만 참조값 자체는 변경되지 않는다
	
	* 참조 타입의 동작이 Call by Reference 처럼 보일 수 있지만 실제로는 참조값의 복사(Call by Value)이다.
	
	기본 데이터 타입 : Stack 메모리에 값 자체가 저장된다
	참조타입 : Stack 메모리에 참조값이 저장되고, 객체 자체는 heap 메모리에 저장


		기본 데이터 타입			참조타입
전달방식		값 자체를 복사하여 전달		참조값(주소)을 복사하여 전달
원본데이터변경여부	메소드 내부 변경이 원본에 영향 없음	참조된 객체를 변경하면 원본 객체에도 영향 있음
참조값 변경여부	의미없음				참조값 자체를 변경해도 원본 참조값에는 영향 없음


3. JVM 메모리에 변수가 저장되는 위치
	기본자료형 : boolean, byte, short, int, float double, char
	참조자료형 : 배열, enum, class, interface, 기본형을 제외한 모든 것들












이중 for문
while문
do~while문
배열(1차원, 2차원)
형변환
if~else if~else
switch
입력메소드


입력메서드, if문, for문 등등........
사용자에게 정수를 입력받고, 입력받은 수 이하의 정수 중에서
3의 배수이면서 5의 배수인 수의 총 개수를 구하시오
총 2개의 메서드 이용.



10x10의 배열에 1~100까지의 수가 있다.

3의 배수이면서 5의 배수인 수의 총 개수와 합, 평균을 구하시오

[조건]
1. 개수를 구할 때 메소드 2개 사용

2. 합, 평균을 구할 때는 findvalue 라는 메소드명을 사용하여 2개 사용

ex) findvalue라는 메서드를 이용하여 합을 구하고, 그 값을 이용하여 
    findvalue라는 메서드를 이용하여 평균을 구하시오






















